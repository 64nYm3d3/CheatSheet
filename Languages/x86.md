# This is Advanced Darkness
Here is a secret that hits my greatest fear, the shellcoder cometh.

This is about x86 (mostly in the context of IA32 progcessors). Opcode fall under such a strange category for me, you code in C and then convert it to x86. You use small registers trying to avoid bad chars but it might be easier to just use msfencode, then again with that you're borrowing someone elses code for these environments.You must modify it too not be detected by AV. Maybe you need the same thing but with less space, what do you do?

A modern computer makes no real distinction between instructions and data. If a processor can be fed instructions when it should be seeing data, it will happily go about executing the passed instructions. This characteristic makes system exploitation possible.

## Quickguide

<reg32>     	Any 32-bit register (EAX, EBX, ECX, EDX, ESI, EDI, ESP, or EBP)
<reg16> 	    Any 16-bit register (AX, BX, CX, or DX)
<reg8>      	Any 8-bit register (AH, BH, CH, DH, AL, BL, CL, or DL)
<reg> 	        Any register
	
<mem> 	A memory address (e.g., [eax], [var + 4], or dword ptr [eax+ebx])
<con32> 	Any 32-bit constant
<con16> 	Any 16-bit constant
<con8> 	Any 8-bit constant
<con> 	Any 8-, 16-, or 32-bit constant


Stack - grows down LIFO

Heap - grows up FIFO

Little Endian - Right to left

Big Endian - Left to Right

Middle Endian - I just like to say this when describing unreadable stuff (but it is unfortunately a real and sometimes referred to as mixed endian format, ARM can produce this format and it's best described in the context of American date time)


POP POP RET is a sequence of instructions needed in order to create SEH (Structured Exception Handler) exploits


### Notable Registers

ESP - Extended stack pointer. The stack pointer points to the memory address where the next operation in the stack will occcur.rol

EIP - Extended Instruction Pointer

DW - Define word, a static data region (like a global variable) assigned two bytes (similarly DB and DD obviouslly being 1 and 4 respectively)


### Register Notes

General Purpose Registers 32 bit

Segment Registers 16 bits

Control Registers 32 bits

Other (varies in size)


#### Memory Management

You need to understand memory management in order to understand how memory overflows from portion of memory to another.

When a program is executed, it is laid out and mapped into memory in this order. 

1. First, the operating system creates an address space in which the program will run. This address space includes the actual program instructions as well as any required data.

2. Next, information is loaded from the program’s executable file to the newly created address space. There are three types of segments: .text , .bss , and .data .

    - The .bss and .data segments are reserved for global variables and are **writeable**.
    - The .data segment contains static initialized data, and the .bss segment contains uninitialized data**writeable**. 
    - The final segment, .text , holds the program instructions and **readable**.
    
3. Finally, the stack and the heap are initialized. The stack is a data structure, more specifically a Last In First Out (LIFO) data structure, which means that the most recent data placed, or pushed, onto the stack is the next item to be removed, or popped, from the stack. A LIFO data structure is ideal for storing transitory information, or information that does not need to be stored for a lengthy period of time. The stack stores local variables, information relating to function calls, and other information used to clean up the stack after a function or procedure is called. The heap is another data structure used to hold program information, more specifically, dynamic variables. The heap is (roughly) a First In First Out (FIFO) data structure. Data is placed and removed from the heap as it builds. 

Another thing it's important to know is that- 

The stack grows down the address space: as more data is added to the stack, it is added at increasingly lower address values.

The heap grows up the address space: As data is added to the heap, it is added at an increasingly higher address value.

~~~
↑ Lower addresses (0x08000000)
Shared libraries
.text
.bss
Heap (grows ↓)
Stack (grows ↑)
env pointer
Argc
↓ Higher addresses (0xbfffffff)
~~~
#### Registers

Exploiting security holes requires a firm grasp of assembly language, because most exploits will require you to write (or modify existing) code in assembly.

Registers are memory and usually tied to hardware. Registers can be grouped into 4 categories.
 * General Purpose
 * Segment
 * Control
 * Other
 
**General-purpose registers** -  Used to perform a range of common mathematical operations. They include registers such as EAX , EBX , and ECX for the IA32, and can be used to store data and addresses, offset addresses, perform counting functions, and many other things. ESP, the extended stack pointer, is one of the most notable and important to understand. ESP points to the memory address where the next stack operation will take place.

**Segment Registers** - Segment registers, such as CS , DS , and SS , are used to keep track of segments and to allow backward compatibility with 16-bit applications.

**Control Registers** - Used to control functions of the processor. Notably, EIP or the Extended Instruction Pointer, which contains the next instruction the machine will execute.

**Other Category** are simply registers that do not fit neatly into the first three categories. One of these registers is the Extended Flags ( EFLAGS ) register, which comprises many single-bit registers that are used to store the results of various tests performed by the processor.

### Recognizing C & C++ code constructs in assembly

C, C++, and C# is the family of C, C was my first programming language with C++ being my second and for those reaspons my own perspective of their difficulty may be skewed. The C family is one of the most widely used languages out there, offering a solid kind of middle ground between between higher level languages and lower ones. While I don't know for certain i believe having an understanding of C is absolutely essential for the rest of this if you have no previous experience with assembly. Understanding how C variables, pointers, functions, and memory allocation are represented by assembly will not only make this easier understand, it will give you foundational knowledge to learn and work with the following assembly.

Let’s look at declaring an integer in C++, then using that same integer for counting:

~~~
int number;

number++;
~~~

Translated into Assembly:

~~~
number dw 0

mov eax,number
inc eax
mov number,eax
~~~


---
Refs:
Shellcoders handbook
